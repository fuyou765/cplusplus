1)介绍

我们知道除了静态内存和栈内存外，每个程序还有一个内存池，这部分内存被称为自由空间或者堆。
程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。
在C++中，动态内存的管理是用一对运算符完成的：new和delete。
new:在动态内存中为对象分配一块空间并返回一个指向该对象的指针，delete：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。
动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。

2)智能指针

为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。
智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。
标准库提供的两种智能指针的区别在于管理底层指针的方法不同；

shared_ptr:

1.基于“引用计数”模型实现，多个shared_ptr可指向同一个动态对象，并维护了一个共享的引用计数器，记录了引用同一对象的shared_ptr实例的数量。
当最后一个指向动态对象的shared_ptr销毁时，才会自动销毁其所指对象(通过delete操作符，也支持自定义的删除器类型Deleter，以实现个性化的资源释放动作。)。

weak_ptr:

1.它是一种弱引用，用于解决仅使用shared_ptr时，造成的循环引用(造成内部对象无法析构，引用计数不能减到0，堆内存不释放，造成内存泄漏)问题，
weak_ptr指向一个对象，并不增减该对象的引用计数器

2.源码中可看出：boost::weak_ptr必须从一个boost::share_ptr或另一个boost::weak_ptr转换而来，
这也说明，进行该对象的内存管理的是那个强引用的boost::share_ptr。boost::weak_ptr只是提供了对管理对象的一个访问手段。
weak_ptr指向shared_ptr指针指向的对象的内存，却并不拥有该内存。）

3.为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，
也就是，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，
一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。从这个角度看，weak_ptr更像是shared_ptr的一个助手而不是智能指针。

unique_ptr

1.是一个独享所有权的智能指针，它提供了严格意义上的所有权。unique_ptr不支持普通的拷贝或赋值操作，但：
      
      a.可以使用release转移“所有权”,
      
      b.可以用在函数返回值中，
      
      c.可以通过move语义作为容器元素使用
